{"version":3,"file":"lib_widget_js.6219976899763855b4c1.js","mappings":";;;;;;;;;AAAa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,mBAAO,CAAC,oDAAO;AAC/C,uBAAuB,mBAAO,CAAC,yDAAsB;AACrD,qBAAqB,mBAAO,CAAC,+CAAc;AAC3C;AACA;AACA;AACA,mDAAmD,qBAAqB;AACxE,8CAA8C,+BAA+B;AAC7E,0DAA0D,YAAY;AACtE;AACA;AACA,mGAAmG,oBAAoB;AACvH,iEAAiE;AACjE;AACA,kBAAe;AACf;;;;;;;;;;;ACpBa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW;AACX,6BAA6B,mBAAO,CAAC,oDAAO;AAC5C,4CAA4C,mBAAO,CAAC,iGAAmB;AACvE,kBAAkB,mBAAO,CAAC,0CAAY;AACtC,qBAAqB,mBAAO,CAAC,gDAAe;AAC5C,oBAAoB,mBAAO,CAAC,kDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wBAAwB;AAC7B,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB,4GAA4G;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA,qGAAqG,wEAAwE;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,8EAA8E;AACrK,qFAAqF,oCAAoC;AACzH;AACA,aAAa;AACb;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gEAAgE;AACrH,KAAK;AACL;AACA,WAAW;AACX,oEAAoE,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClOa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,uBAAuB,GAAG,yBAAyB;AACvE,6BAA6B,mBAAO,CAAC,oDAAO;AAC5C,yCAAyC,mBAAO,CAAC,iGAAmB;AACpE,kBAAkB,mBAAO,CAAC,2FAAkB;AAC5C,kBAAkB,mBAAO,CAAC,0CAAY;AACtC,gBAAgB,mBAAO,CAAC,mGAAmB;AAC3C;AACA,gCAAgC,EAAE,UAAU,EAAE,UAAU,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAA6C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,YAAY;AACjC,oBAAoB,WAAW;AAC/B,sBAAsB,gBAAgB;AACtC,uBAAuB,iBAAiB;AACxC,kCAAkC,QAAQ,eAAe,QAAQ;AACjE;AACA,uBAAuB,OAAO,WAAW,MAAM;AAC/C,gCAAgC,WAAW,IAAI,WAAW,IAAI,WAAW,IAAI,qBAAqB;AAClG,WAAW;AACX;AACA,yBAAyB;AACzB,sDAAsD,mBAAmB;AACzE;AACA,kBAAkB;AAClB;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,+DAA+D;AAC/D,6BAA6B,OAAO;AACpC,4BAA4B,MAAM;AAClC,8BAA8B,iBAAiB;AAC/C,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;AACA,uBAAuB;AACvB,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA,SAAS,uBAAuB,aAAa,mBAAmB,aAAa,iBAAiB;AAC9F,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW,oBAAoB,8FAA8F,4BAA4B;AACtK;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,yEAAyE,4FAA4F,8BAA8B;AACtQ;AACA,gEAAgE;AAChE;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB,uEAAuE;AACvE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,sFAAsF,+CAA+C;AACrI,mFAAmF,yEAAyE;AAC5J;AACA,iBAAiB;AACjB,yDAAyD,eAAe;AACxE;AACA,kBAAkB,OAAO;AACzB;AACA,kBAAkB,QAAQ,SAAS;AACnC,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjOa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sCAAO;AAC5B,aAAa,mBAAO,CAAC,kDAAa;AAClC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,qBAAqB;AAC7F,gBAAgB,mBAAO,CAAC,oDAAO;AAC/B,eAAe,mBAAO,CAAC,2DAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mGAAmG,kJAAkJ,0JAA0J;AAC/Y;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;;;;;;;;;;;AClIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,mBAAmB,GAAG,wBAAwB,GAAG,uBAAuB;AAC3F,gBAAgB,mBAAO,CAAC,oDAAO;AAC/B,0BAA0B,mBAAO,CAAC,2DAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA,2BAA2B,oDAAoD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA,KAAK;AACL,CAAC;AACD;;;;;;;;;;;AClLa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,2DAAmB;AACxC,aAAa,mBAAO,CAAC,6CAAY;AACjC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,0BAA0B;AAC7F,gBAAgB,mBAAO,CAAC,oDAAO;AAC/B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;;ACjDa;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,sBAAsB;AAC5C;AACA;AACA;AACA,aAAa,mBAAO,CAAC,uCAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;;ACpBa;AACb;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,oBAAoB;AAC1C,eAAe,mBAAO,CAAC,oFAAuB;AAC9C,sCAAsC,mBAAO,CAAC,2CAAe;AAC7D,gCAAgC,mBAAO,CAAC,oDAAO;AAC/C,oCAAoC,mBAAO,CAAC,4DAAW;AACvD,kBAAkB,mBAAO,CAAC,mCAAW;AACrC;AACA,mBAAO,CAAC,2CAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB,8QAA8Q;AAChW;AACA;AACA,oBAAoB;AACpB,2CAA2C;AAC3C;AACA;AACA;AACA,wCAAwC;AACxC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;AC3CA;AACA,kCAAkC,mBAAO,CAAC,qGAAgD;AAC1F;AACA;AACA,0CAA0C,qBAAqB,GAAG;AAClE;AACA;;;;;;;;;;;ACNA,UAAU,mBAAO,CAAC,oJAAwE;AAC1F,0BAA0B,mBAAO,CAAC,qHAAuD;;AAEzF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA","sources":["webpack://pawls-ext/./lib/ReactWidget.js","webpack://pawls-ext/./lib/components/PDF.js","webpack://pawls-ext/./lib/components/Selection.js","webpack://pawls-ext/./lib/components/index.js","webpack://pawls-ext/./lib/context/AnnotationStore.js","webpack://pawls-ext/./lib/context/PDFStore.js","webpack://pawls-ext/./lib/context/index.js","webpack://pawls-ext/./lib/hooks/widget-model.js","webpack://pawls-ext/./lib/version.js","webpack://pawls-ext/./lib/widget.js","webpack://pawls-ext/./css/widget.css","webpack://pawls-ext/./css/widget.css?a195"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = __importDefault(require(\"react\"));\nconst widget_model_1 = require(\"./hooks/widget-model\");\nconst components_1 = require(\"./components\");\nfunction ReactWidget(props) {\n    const [data, setName] = widget_model_1.useModelState('value');\n    console.log('prev', data);\n    return (react_1.default.createElement(\"div\", { className: \"Widget\" },\n        react_1.default.createElement(\"h1\", { onChange: () => setName(data) }, \"Hello\"),\n        react_1.default.createElement(components_1.PDF, { data: data })));\n}\nfunction withModelContext(Component) {\n    return (props) => (react_1.default.createElement(widget_model_1.WidgetModelContext.Provider, { value: props.model },\n        react_1.default.createElement(Component, Object.assign({}, props))));\n}\nexports.default = withModelContext(ReactWidget);\n//# sourceMappingURL=ReactWidget.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PDF = void 0;\nconst react_1 = __importStar(require(\"react\"));\nconst styled_components_1 = __importDefault(require(\"styled-components\"));\nconst context_1 = require(\"../context\");\nconst components_1 = require(\"../components\");\nconst Selection_1 = require(\"./Selection\");\nclass PDFPageRenderer {\n    constructor(page, canvas, onError) {\n        this.page = page;\n        this.canvas = canvas;\n        this.onError = onError;\n    }\n    cancelCurrentRender() {\n        if (this.currentRenderTask === undefined) {\n            return;\n        }\n        this.currentRenderTask.promise.then(() => { }, (err) => {\n            if (err instanceof Error && err.message.indexOf('Rendering cancelled') !== -1) {\n                // Swallow the error that's thrown when the render is canceled.\n                return;\n            }\n            const e = err instanceof Error ? err : new Error(err);\n            this.onError(e);\n        });\n        this.currentRenderTask.cancel();\n    }\n    render(scale) {\n        console.log('pdfjs', this.page);\n        const viewport = this.page.getViewport({ scale });\n        this.canvas.height = viewport.height;\n        this.canvas.width = viewport.width;\n        const canvasContext = this.canvas.getContext('2d');\n        if (canvasContext === null) {\n            throw new Error('No canvas context');\n        }\n        this.currentRenderTask = this.page.render({ canvasContext, viewport });\n        return this.currentRenderTask;\n    }\n    rescaleAndRender(scale) {\n        this.cancelCurrentRender();\n        return this.render(scale);\n    }\n}\nfunction getPageBoundsFromCanvas(canvas) {\n    if (canvas.parentElement === null) {\n        throw new Error('No canvas parent');\n    }\n    const parent = canvas.parentElement;\n    const parentStyles = getComputedStyle(canvas.parentElement);\n    const leftPadding = parseFloat(parentStyles.paddingLeft || '0');\n    const left = parent.offsetLeft + leftPadding;\n    const topPadding = parseFloat(parentStyles.paddingTop || '0');\n    const top = parent.offsetTop + topPadding;\n    const parentWidth = parent.clientWidth - leftPadding - parseFloat(parentStyles.paddingRight || '0');\n    const parentHeight = parent.clientHeight - topPadding - parseFloat(parentStyles.paddingBottom || '0');\n    return {\n        left,\n        top,\n        right: left + parentWidth,\n        bottom: top + parentHeight,\n    };\n}\nconst Page = ({ pageInfo, onError }) => {\n    const canvasRef = react_1.useRef(null);\n    const [isVisible, setIsVisible] = react_1.useState(false);\n    const [scale, setScale] = react_1.useState(1);\n    const annotationStore = react_1.useContext(context_1.AnnotationStore);\n    const containerRef = react_1.useRef(null);\n    const [selection, setSelection] = react_1.useState();\n    const annotations = annotationStore.pdfAnnotations.annotations.filter((a) => a.page === pageInfo.page.pageNumber - 1);\n    react_1.useEffect(() => {\n        try {\n            const determinePageVisiblity = () => {\n                if (canvasRef.current !== null) {\n                    const windowTop = 0;\n                    const windowBottom = window.innerHeight;\n                    const rect = canvasRef.current.getBoundingClientRect();\n                    setIsVisible(\n                    // Top is in within window\n                    (windowTop < rect.top && rect.top < windowBottom) ||\n                        // Bottom is in within window\n                        (windowTop < rect.bottom && rect.bottom < windowBottom) ||\n                        // top is negative and bottom is +ve\n                        (rect.top < windowTop && rect.bottom > windowTop));\n                }\n            };\n            if (canvasRef.current === null) {\n                onError(new Error('No canvas element'));\n                return;\n            }\n            pageInfo.bounds = getPageBoundsFromCanvas(canvasRef.current);\n            const renderer = new PDFPageRenderer(pageInfo.page, canvasRef.current, onError);\n            renderer.render(pageInfo.scale);\n            determinePageVisiblity();\n            const handleResize = () => {\n                if (canvasRef.current === null) {\n                    onError(new Error('No canvas element'));\n                    return;\n                }\n                pageInfo.bounds = getPageBoundsFromCanvas(canvasRef.current);\n                renderer.rescaleAndRender(pageInfo.scale);\n                setScale(pageInfo.scale);\n                determinePageVisiblity();\n            };\n            window.addEventListener('resize', handleResize);\n            window.addEventListener('scroll', determinePageVisiblity);\n            return () => {\n                window.removeEventListener('resize', handleResize);\n                window.removeEventListener('scroll', determinePageVisiblity);\n            };\n        }\n        catch (e) {\n            onError(e);\n        }\n    }, [pageInfo, onError]); // We deliberately only run this once.\n    return (react_1.default.createElement(PageAnnotationsContainer, { ref: containerRef, onMouseDown: (event) => {\n            if (containerRef.current === null) {\n                throw new Error('No Container');\n            }\n            if (!selection) {\n                const left = event.pageX - containerRef.current.offsetLeft;\n                const top = event.pageY - containerRef.current.offsetTop;\n                setSelection({\n                    left,\n                    top,\n                    right: left,\n                    bottom: top,\n                });\n            }\n        }, onMouseMove: selection\n            ? (event) => {\n                if (containerRef.current === null) {\n                    throw new Error('No Container');\n                }\n                setSelection(Object.assign(Object.assign({}, selection), { right: event.pageX - containerRef.current.offsetLeft, bottom: event.pageY - containerRef.current.offsetTop }));\n            }\n            : undefined, onMouseUp: selection\n            ? () => {\n                if (annotationStore.activeLabel) {\n                    const newAnnotation = context_1.getNewAnnotation(\n                    // TODO(Mark): Change\n                    pageInfo, selection, annotationStore.activeLabel, annotationStore.freeFormAnnotations);\n                    if (newAnnotation) {\n                        annotationStore.setPdfAnnotations(annotationStore.pdfAnnotations.withNewAnnotation(newAnnotation));\n                    }\n                }\n                setSelection(undefined);\n            }\n            : undefined },\n        react_1.default.createElement(PageCanvas, { ref: canvasRef }),\n        // We only render the tokens if the page is visible, as rendering them all makes the\n        // page slow and/or crash.\n        scale &&\n            isVisible &&\n            annotations.map((annotation) => (react_1.default.createElement(components_1.Selection, { pageInfo: pageInfo, annotation: annotation, key: annotation.toString() }))),\n        selection && annotationStore.activeLabel\n            ? (() => {\n                if (selection && annotationStore.activeLabel) {\n                    const annotation = pageInfo.getAnnotationForBounds(context_1.normalizeBounds(selection), annotationStore.activeLabel);\n                    const tokens = annotation &&\n                        annotation.tokens &&\n                        !annotationStore.freeFormAnnotations\n                        ? annotation.tokens\n                        : null;\n                    return (react_1.default.createElement(react_1.default.Fragment, null,\n                        react_1.default.createElement(Selection_1.SelectionBoundary, { color: annotationStore.activeLabel.color, bounds: selection, selected: false }),\n                        react_1.default.createElement(Selection_1.SelectionTokens, { pageInfo: pageInfo, tokens: tokens })));\n                }\n            })()\n            : null));\n};\nconst PDF = ({ data }) => {\n    // const pdfStore = useContext(PDFStore);\n    var pdfStore = JSON.parse(data);\n    console.log('store', pdfStore);\n    pdfStore.onError = function (err) {\n        console.error('Unexpected Error rendering PDF', err);\n    };\n    // TODO (@codeviking): Use error boundaries to capture these.\n    if (!pdfStore.doc) {\n        throw new Error('No Document');\n    }\n    if (!pdfStore.pages) {\n        throw new Error('Document without Pages');\n    }\n    return (react_1.default.createElement(react_1.default.Fragment, null, pdfStore.pages.map((p) => {\n        return react_1.default.createElement(Page, { key: p.page.pageNumber, pageInfo: p, onError: pdfStore.onError });\n    })));\n};\nexports.PDF = PDF;\nconst PageAnnotationsContainer = styled_components_1.default.div(({ theme }) => `\r\n    position: relative;\r\n    box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.2);\r\n    margin: 0 0 2;\r\n\r\n    &:last-child {\r\n        margin-bottom: 0;\r\n    }\r\n`);\nconst PageCanvas = styled_components_1.default.canvas `\r\n    display: block;\r\n`;\n//# sourceMappingURL=PDF.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Selection = exports.SelectionTokens = exports.SelectionBoundary = void 0;\nconst react_1 = __importStar(require(\"react\"));\nconst styled_components_1 = __importStar(require(\"styled-components\"));\nconst varnish_1 = require(\"@allenai/varnish\");\nconst context_1 = require(\"../context\");\nconst icons_1 = require(\"@ant-design/icons\");\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!result) {\n        throw new Error('Unable to parse color.');\n    }\n    return {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n    };\n}\nfunction getBorderWidthFromBounds(bounds) {\n    //\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    if (width < 100 || height < 100) {\n        return 1;\n    }\n    else {\n        return 3;\n    }\n}\nconst SelectionBoundary = ({ color, bounds, children, onClick, selected, }) => {\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const rotateY = width < 0 ? -180 : 0;\n    const rotateX = height < 0 ? -180 : 0;\n    const rgbColor = hexToRgb(color);\n    const border = getBorderWidthFromBounds(bounds);\n    return (react_1.default.createElement(\"span\", { onClick: (e) => {\n            // Here we are preventing the default PdfAnnotationsContainer\n            // behaviour of drawing a new bounding box if the shift key\n            // is pressed in order to allow users to select multiple\n            // annotations and associate them together with a relation.\n            if (e.shiftKey && onClick) {\n                e.stopPropagation();\n                onClick();\n            }\n        }, onMouseDown: (e) => {\n            if (e.shiftKey && onClick) {\n                e.stopPropagation();\n            }\n        }, style: {\n            position: 'absolute',\n            left: `${bounds.left}px`,\n            top: `${bounds.top}px`,\n            width: `${Math.abs(width)}px`,\n            height: `${Math.abs(height)}px`,\n            transform: `rotateY(${rotateY}deg) rotateX(${rotateX}deg)`,\n            transformOrigin: 'top left',\n            border: `${border}px solid ${color}`,\n            background: `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, ${selected ? 0.3 : 0.1})`,\n        } }, children || null));\n};\nexports.SelectionBoundary = SelectionBoundary;\nconst TokenSpan = styled_components_1.default.span(({ theme, isSelected }) => `\n    position: absolute;\n    background: ${isSelected ? theme.color.B3 : 'none'};\n    opacity: 0.2;\n    border-radius: 3px;\n`);\nconst SelectionTokens = ({ pageInfo, tokens }) => {\n    return (react_1.default.createElement(react_1.default.Fragment, null, tokens &&\n        tokens.map((t, i) => {\n            const b = pageInfo.getScaledTokenBounds(pageInfo.tokens[t.tokenIndex]);\n            return (react_1.default.createElement(TokenSpan, { key: i, isSelected: true, style: {\n                    left: `${b.left}px`,\n                    top: `${b.top}px`,\n                    width: `${b.right - b.left}px`,\n                    height: `${b.bottom - b.top}px`,\n                    // Tokens don't respond to pointerEvents because\n                    // they are ontop of the bounding boxes and the canvas,\n                    // which do respond to pointer events.\n                    pointerEvents: 'none',\n                } }));\n        })));\n};\nexports.SelectionTokens = SelectionTokens;\nconst EditLabelModal = ({ annotation, onHide }) => {\n    const annotationStore = react_1.useContext(context_1.AnnotationStore);\n    const [selectedLabel, setSelectedLabel] = react_1.useState(annotation.label);\n    // There are onMouseDown listeners on the <canvas> that handle the\n    // creation of new annotations. We use this function to prevent that\n    // from being triggered when the user engages with other UI elements.\n    const onMouseDown = (e) => {\n        e.stopPropagation();\n    };\n    react_1.useEffect(() => {\n        const onKeyPress = (e) => {\n            // Ref to https://github.com/allenai/pawls/blob/0f3e5153241502eb68e46f582ed4b28112e2f765/ui/src/components/sidebar/Labels.tsx#L20\n            // Numeric keys 1-9\n            if (e.keyCode >= 49 && e.keyCode <= 57) {\n                const index = Number.parseInt(e.key) - 1;\n                if (index < annotationStore.labels.length) {\n                    const selectedLabel = annotationStore.labels[index];\n                    annotationStore.setPdfAnnotations(annotationStore.pdfAnnotations\n                        .deleteAnnotation(annotation)\n                        .withNewAnnotation(annotation.update({ label: selectedLabel })));\n                    onHide();\n                }\n            }\n        };\n        window.addEventListener('keydown', onKeyPress);\n        return () => {\n            window.removeEventListener('keydown', onKeyPress);\n        };\n    }, [annotationStore, annotation]);\n    return (react_1.default.createElement(varnish_1.Modal, { title: \"Edit Label\", onCancel: onHide, onOk: () => {\n            // Remove the annotation and add a copy with the updated label.\n            // TODO: This might have side-effects to the relation mechanism.\n            // Some additional testing is warranted.\n            annotationStore.setPdfAnnotations(annotationStore.pdfAnnotations\n                .deleteAnnotation(annotation)\n                .withNewAnnotation(annotation.update({ label: selectedLabel })));\n            onHide();\n        }, cancelButtonProps: { onMouseDown }, okButtonProps: { onMouseDown }, visible: true },\n        react_1.default.createElement(varnish_1.Select, { value: selectedLabel.text, onMouseDown: onMouseDown, onChange: (labelText) => {\n                const label = annotationStore.labels.find((l) => l.text === labelText);\n                if (!label) {\n                    return;\n                }\n                setSelectedLabel(label);\n            }, style: { display: 'block' } }, annotationStore.labels.map((l) => (react_1.default.createElement(varnish_1.Select.Option, { value: l.text, key: l.text }, l.text))))));\n};\nconst Selection = ({ pageInfo, annotation, showInfo = true }) => {\n    const label = annotation.label;\n    const theme = react_1.useContext(styled_components_1.ThemeContext);\n    const [isEditLabelModalVisible, setIsEditLabelModalVisible] = react_1.useState(false);\n    const annotationStore = react_1.useContext(context_1.AnnotationStore);\n    let color;\n    if (!label) {\n        color = theme.color.N4.hex; // grey as the default.\n    }\n    else {\n        color = label.color;\n    }\n    const bounds = pageInfo.getScaledBounds(annotation.bounds);\n    const border = getBorderWidthFromBounds(bounds);\n    const removeAnnotation = () => {\n        annotationStore.setPdfAnnotations(annotationStore.pdfAnnotations.deleteAnnotation(annotation));\n    };\n    const onShiftClick = () => {\n        const current = annotationStore.selectedAnnotations.slice(0);\n        // Current contains this annotation, so we remove it.\n        if (current.some((other) => other.id === annotation.id)) {\n            const next = current.filter((other) => other.id !== annotation.id);\n            annotationStore.setSelectedAnnotations(next);\n            // Otherwise we add it.\n        }\n        else {\n            current.push(annotation);\n            annotationStore.setSelectedAnnotations(current);\n        }\n    };\n    const selected = annotationStore.selectedAnnotations.includes(annotation);\n    return (react_1.default.createElement(react_1.default.Fragment, null,\n        react_1.default.createElement(exports.SelectionBoundary, { color: color, bounds: bounds, onClick: onShiftClick, selected: selected }, showInfo && !annotationStore.hideLabels ? (react_1.default.createElement(SelectionInfo, { border: border, color: color },\n            react_1.default.createElement(\"span\", null, label.text),\n            react_1.default.createElement(icons_1.EditFilled, { onClick: (e) => {\n                    e.stopPropagation();\n                    setIsEditLabelModalVisible(true);\n                }, onMouseDown: (e) => {\n                    e.stopPropagation();\n                } }),\n            react_1.default.createElement(icons_1.CloseCircleFilled, { onClick: (e) => {\n                    e.stopPropagation();\n                    removeAnnotation();\n                }, \n                // We have to prevent the default behaviour for\n                // the pdf canvas here, in order to be able to capture\n                // the click event.\n                onMouseDown: (e) => {\n                    e.stopPropagation();\n                } }))) : null),\n        // NOTE: It's important that the parent element of the tokens\n        // is the PDF canvas, because we need their absolute position\n        // to be relative to that and not another absolute/relatively\n        // positioned element. This is why SelectionTokens are not inside\n        // SelectionBoundary.\n        annotation.tokens ? (react_1.default.createElement(exports.SelectionTokens, { pageInfo: pageInfo, tokens: annotation.tokens })) : null,\n        isEditLabelModalVisible ? (react_1.default.createElement(EditLabelModal, { annotation: annotation, onHide: () => setIsEditLabelModalVisible(false) })) : null));\n};\nexports.Selection = Selection;\nconst SelectionInfo = styled_components_1.default.div(({ border, color }) => `\n        position: absolute;\n        right: -${border}px;\n        transform:translateY(-100%);\n        border: ${border} solid  ${color};\n        background: ${color};\n        font-weight: bold;\n        font-size: 12px;\n        user-select: none;\n\n        * {\n            margin: 2px;\n            vertical-align: middle;\n        }\n    `);\n//# sourceMappingURL=Selection.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./PDF\"), exports);\n__exportStar(require(\"./Selection\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnnotationStore = exports.PdfAnnotations = exports.Annotation = exports.RelationGroup = void 0;\nconst react_1 = require(\"react\");\nconst uuid_1 = require(\"uuid\");\nclass RelationGroup {\n    constructor(sourceIds, targetIds, label) {\n        this.sourceIds = sourceIds;\n        this.targetIds = targetIds;\n        this.label = label;\n    }\n    updateForAnnotationDeletion(a) {\n        const sourceEmpty = this.sourceIds.length === 0;\n        const targetEmpty = this.targetIds.length === 0;\n        const newSourceIds = this.sourceIds.filter((id) => id !== a.id);\n        const newTargetIds = this.targetIds.filter((id) => id !== a.id);\n        const nowSourceEmpty = this.sourceIds.length === 0;\n        const nowTargetEmpty = this.targetIds.length === 0;\n        // Only target had any annotations, now it has none,\n        // so delete.\n        if (sourceEmpty && nowTargetEmpty) {\n            return undefined;\n        }\n        // Only source had any annotations, now it has none,\n        // so delete.\n        if (targetEmpty && nowSourceEmpty) {\n            return undefined;\n        }\n        // Source was not empty, but now it is, so delete.\n        if (!sourceEmpty && nowSourceEmpty) {\n            return undefined;\n        }\n        // Target was not empty, but now it is, so delete.\n        if (!targetEmpty && nowTargetEmpty) {\n            return undefined;\n        }\n        return new RelationGroup(newSourceIds, newTargetIds, this.label);\n    }\n    static fromObject(obj) {\n        return new RelationGroup(obj.sourceIds, obj.targetIds, obj.label);\n    }\n}\nexports.RelationGroup = RelationGroup;\nclass Annotation {\n    constructor(bounds, page, label, tokens = null, id = undefined) {\n        this.bounds = bounds;\n        this.page = page;\n        this.label = label;\n        this.tokens = tokens;\n        this.id = id || uuid_1.v4();\n    }\n    toString() {\n        return this.id;\n    }\n    /**\n     * Returns a deep copy of the provided Annotation with the applied\n     * changes.\n     */\n    update(delta = {}) {\n        var _a, _b, _c, _d, _e;\n        return new Annotation((_a = delta.bounds) !== null && _a !== void 0 ? _a : Object.assign({}, this.bounds), (_b = delta.page) !== null && _b !== void 0 ? _b : this.page, (_c = delta.label) !== null && _c !== void 0 ? _c : Object.assign({}, this.label), (_d = delta.tokens) !== null && _d !== void 0 ? _d : (_e = this.tokens) === null || _e === void 0 ? void 0 : _e.map((t) => Object.assign({}, t)), this.id);\n    }\n    static fromObject(obj) {\n        return new Annotation(obj.bounds, obj.page, obj.label, obj.tokens, obj.id);\n    }\n}\nexports.Annotation = Annotation;\nclass PdfAnnotations {\n    constructor(annotations, relations, unsavedChanges = false) {\n        this.annotations = annotations;\n        this.relations = relations;\n        this.unsavedChanges = unsavedChanges;\n    }\n    saved() {\n        return new PdfAnnotations(this.annotations, this.relations, false);\n    }\n    withNewAnnotation(a) {\n        return new PdfAnnotations(this.annotations.concat([a]), this.relations, true);\n    }\n    withNewRelation(r) {\n        return new PdfAnnotations(this.annotations, this.relations.concat([r]), true);\n    }\n    deleteAnnotation(a) {\n        const newAnnotations = this.annotations.filter((ann) => ann.id !== a.id);\n        const newRelations = this.relations\n            .map((r) => r.updateForAnnotationDeletion(a))\n            .filter((r) => r !== undefined);\n        return new PdfAnnotations(newAnnotations, newRelations, true);\n    }\n    undoAnnotation() {\n        const popped = this.annotations.pop();\n        if (!popped) {\n            // No annotations, nothing to update\n            return this;\n        }\n        const newRelations = this.relations\n            .map((r) => r.updateForAnnotationDeletion(popped))\n            .filter((r) => r !== undefined);\n        return new PdfAnnotations(this.annotations, newRelations, true);\n    }\n}\nexports.PdfAnnotations = PdfAnnotations;\nexports.AnnotationStore = react_1.createContext({\n    pdfAnnotations: new PdfAnnotations([], []),\n    labels: [],\n    activeLabel: undefined,\n    setActiveLabel: (_) => {\n        throw new Error('Unimplemented');\n    },\n    relationLabels: [],\n    activeRelationLabel: undefined,\n    setActiveRelationLabel: (_) => {\n        throw new Error('Unimplemented');\n    },\n    selectedAnnotations: [],\n    setSelectedAnnotations: (_) => {\n        throw new Error('Unimplemented');\n    },\n    setPdfAnnotations: (_) => {\n        throw new Error('Unimplemented');\n    },\n    freeFormAnnotations: false,\n    toggleFreeFormAnnotations: (_) => {\n        throw new Error('Unimplemented');\n    },\n    hideLabels: false,\n    setHideLabels: (_) => {\n        throw new Error('Unimplemented');\n    },\n});\n//# sourceMappingURL=AnnotationStore.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PDFStore = exports.PDFPageInfo = exports.getNewAnnotation = exports.normalizeBounds = void 0;\nconst react_1 = require(\"react\");\nconst AnnotationStore_1 = require(\"./AnnotationStore\");\n/**\n * Returns the provided bounds scaled by the provided factor.\n */\nfunction scaled(bounds, scale) {\n    return {\n        left: bounds.left * scale,\n        top: bounds.top * scale,\n        right: bounds.right * scale,\n        bottom: bounds.bottom * scale,\n    };\n}\n/**\n * Computes a bound which contains all of the bounds passed as arguments.\n */\nfunction spanningBound(bounds, padding = 3) {\n    // Start with a bounding box for which any bound would be\n    // contained within, meaning we immediately update maxBound.\n    const maxBound = {\n        left: Number.MAX_VALUE,\n        top: Number.MAX_VALUE,\n        right: 0,\n        bottom: 0,\n    };\n    bounds.forEach((bound) => {\n        maxBound.bottom = Math.max(bound.bottom, maxBound.bottom);\n        maxBound.top = Math.min(bound.top, maxBound.top);\n        maxBound.left = Math.min(bound.left, maxBound.left);\n        maxBound.right = Math.max(bound.right, maxBound.right);\n    });\n    maxBound.top = maxBound.top - padding;\n    maxBound.left = maxBound.left - padding;\n    maxBound.right = maxBound.right + padding;\n    maxBound.bottom = maxBound.bottom + padding;\n    return maxBound;\n}\n/**\n * Returns the provided bounds in their normalized form. Normalized means that the left\n * coordinate is always less than the right coordinate, and that the top coordinate is always\n * left than the bottom coordinate.\n *\n * This is required because objects in the DOM are positioned and sized by setting their top-left\n * corner, width and height. This means that when a user composes a selection and moves to the left,\n * or up, from where they started might result in a negative width and/or height. We don't normalize\n * these values as we're tracking the mouse as it'd result in the wrong visual effect. Instead we\n * rotate the bounds we render on the appropriate axis. This means we need to account for this\n * later when calculating what tokens the bounds intersect with.\n */\nfunction normalizeBounds(b) {\n    const normalized = Object.assign({}, b);\n    if (b.right < b.left) {\n        const l = b.left;\n        normalized.left = b.right;\n        normalized.right = l;\n    }\n    if (b.bottom < b.top) {\n        const t = b.top;\n        normalized.top = b.bottom;\n        normalized.bottom = t;\n    }\n    return normalized;\n}\nexports.normalizeBounds = normalizeBounds;\n/**\n * Returns true if the provided bounds overlap.\n */\nfunction doOverlap(a, b) {\n    if (a.left >= b.right || a.right <= b.left) {\n        return false;\n    }\n    else if (a.bottom <= b.top || a.top >= b.bottom) {\n        return false;\n    }\n    return true;\n}\nfunction getNewAnnotation(page, selection, activeLabel, freeform) {\n    let annotation;\n    const normalized = normalizeBounds(selection);\n    if (freeform) {\n        annotation = page.getFreeFormAnnotationForBounds(normalized, activeLabel);\n    }\n    else {\n        annotation = page.getAnnotationForBounds(normalized, activeLabel);\n    }\n    return annotation;\n}\nexports.getNewAnnotation = getNewAnnotation;\nclass PDFPageInfo {\n    constructor(page, tokens = [], bounds) {\n        this.page = page;\n        this.tokens = tokens;\n        this.bounds = bounds;\n    }\n    getFreeFormAnnotationForBounds(selection, label) {\n        if (this.bounds === undefined) {\n            throw new Error('Unknown Page Bounds');\n        }\n        // Here we invert the scale, because the user has drawn this bounding\n        // box, so it is *already* scaled with respect to the client's view. For\n        // the annotation, we want to remove this, because storing it with respect\n        // to the PDF page's original scale means we can render it everywhere.\n        const bounds = scaled(selection, 1 / this.scale);\n        return new AnnotationStore_1.Annotation(bounds, this.page.pageNumber - 1, label);\n    }\n    getAnnotationForBounds(selection, label) {\n        /* This function is quite complicated. Our objective here is to\n           compute overlaps between a bounding box provided by a user and\n           grobid token spans associated with a pdf. The complexity here is\n           that grobid spans are relative to an absolute scale of the pdf,\n           but our user's bounding box is relative to the pdf rendered in their\n           client.\n\n           The critical key here is that anything we *store* must be relative\n           to the underlying pdf. So for example, inside the for loop, we are\n           computing:\n\n           whether a grobid token (tokenBound), scaled to the current scale of the\n           pdf in the client (scaled(tokenBound, this.scale)), is overlapping with\n           the bounding box drawn by the user (selection).\n\n           But! Once we have computed this, we store the grobid tokens and the bound\n           that contains all of them relative to the *original grobid tokens*.\n\n           This means that the stored data is not tied to a particular scale, and we\n           can re-scale it when we need to (mainly when the user resizes the browser window).\n         */\n        if (this.bounds === undefined) {\n            throw new Error('Unknown Page Bounds');\n        }\n        const ids = [];\n        const tokenBounds = [];\n        for (let i = 0; i < this.tokens.length; i++) {\n            const tokenBound = this.getTokenBounds(this.tokens[i]);\n            if (doOverlap(scaled(tokenBound, this.scale), selection)) {\n                ids.push({ pageIndex: this.page.pageNumber - 1, tokenIndex: i });\n                tokenBounds.push(tokenBound);\n            }\n        }\n        if (ids.length === 0) {\n            return undefined;\n        }\n        const bounds = spanningBound(tokenBounds);\n        return new AnnotationStore_1.Annotation(bounds, this.page.pageNumber - 1, label, ids);\n    }\n    getScaledTokenBounds(t) {\n        return this.getScaledBounds(this.getTokenBounds(t));\n    }\n    getTokenBounds(t) {\n        const b = {\n            left: t.x,\n            top: t.y,\n            right: t.x + t.width,\n            bottom: t.y + t.height,\n        };\n        return b;\n    }\n    getScaledBounds(b) {\n        return scaled(b, this.scale);\n    }\n    get scale() {\n        if (this.bounds === undefined) {\n            throw new Error('Unknown Page Bounds');\n        }\n        const pdfPageWidth = this.page.view[2] - this.page.view[1];\n        const domPageWidth = this.bounds.right - this.bounds.left;\n        return domPageWidth / pdfPageWidth;\n    }\n}\nexports.PDFPageInfo = PDFPageInfo;\nexports.PDFStore = react_1.createContext({\n    onError: (_) => {\n        throw new Error('Unimplemented');\n    },\n});\n//# sourceMappingURL=PDFStore.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./AnnotationStore\"), exports);\n__exportStar(require(\"./PDFStore\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useModel = exports.useModelEvent = exports.useModelState = exports.WidgetModelContext = void 0;\nconst react_1 = require(\"react\");\nexports.WidgetModelContext = react_1.createContext(undefined);\n// HOOKS\n//============================================================================================\n/**\n *\n * @param name property name in the Python model object.\n * @returns model state and set state function.\n */\nfunction useModelState(name) {\n    const model = useModel();\n    const [state, setState] = react_1.useState(model === null || model === void 0 ? void 0 : model.get(name));\n    useModelEvent(`change:${name}`, (model) => {\n        setState(model.get(name));\n    }, [name]);\n    function updateModel(val, options) {\n        model === null || model === void 0 ? void 0 : model.set(name, val, options);\n        model === null || model === void 0 ? void 0 : model.save_changes();\n    }\n    return [state, updateModel];\n}\nexports.useModelState = useModelState;\n/**\n * Subscribes a listener to the model event loop.\n * @param event String identifier of the event that will trigger the callback.\n * @param callback Action to perform when event happens.\n * @param deps Dependencies that should be kept up to date within the callback.\n */\nfunction useModelEvent(event, callback, deps) {\n    const model = useModel();\n    const dependencies = deps === undefined ? [model] : [...deps, model];\n    react_1.useEffect(() => {\n        const callbackWrapper = (e) => model && callback(model, e);\n        model === null || model === void 0 ? void 0 : model.on(event, callbackWrapper);\n        return () => void (model === null || model === void 0 ? void 0 : model.unbind(event, callbackWrapper));\n    }, dependencies);\n}\nexports.useModelEvent = useModelEvent;\n/**\n * An escape hatch in case you want full access to the model.\n * @returns Python model\n */\nfunction useModel() {\n    return react_1.useContext(exports.WidgetModelContext);\n}\nexports.useModel = useModel;\n//# sourceMappingURL=widget-model.js.map","\"use strict\";\n// Copyright (c) \n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MODULE_NAME = exports.MODULE_VERSION = void 0;\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst data = require('../package.json');\n/**\n * The _model_module_version/_view_module_version this package implements.\n *\n * The html widget manager assumes that this is the same as the npm package\n * version number.\n */\nexports.MODULE_VERSION = data.version;\n/*\n * The current package name.\n */\nexports.MODULE_NAME = data.name;\n//# sourceMappingURL=version.js.map","\"use strict\";\n// Copyright (c) \n// Distributed under the terms of the Modified BSD License.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExampleView = exports.ExampleModel = void 0;\nconst base_1 = require(\"@jupyter-widgets/base\");\nconst ReactWidget_1 = __importDefault(require(\"./ReactWidget\"));\nconst react_1 = __importDefault(require(\"react\"));\nconst react_dom_1 = __importDefault(require(\"react-dom\"));\nconst version_1 = require(\"./version\");\n// Import the CSS\nrequire(\"../css/widget.css\");\n// Your widget state goes here. Make sure to update the corresponding\n// Python state in example.py\nconst defaultModelProperties = {\n    value: 'Hello World',\n};\nclass ExampleModel extends base_1.DOMWidgetModel {\n    defaults() {\n        return Object.assign(Object.assign(Object.assign({}, super.defaults()), { _model_name: ExampleModel.model_name, _model_module: ExampleModel.model_module, _model_module_version: ExampleModel.model_module_version, _view_name: ExampleModel.view_name, _view_module: ExampleModel.view_module, _view_module_version: ExampleModel.view_module_version }), defaultModelProperties);\n    }\n}\nexports.ExampleModel = ExampleModel;\nExampleModel.serializers = Object.assign({}, base_1.DOMWidgetModel.serializers);\nExampleModel.model_name = 'ExampleModel';\nExampleModel.model_module = version_1.MODULE_NAME;\nExampleModel.model_module_version = version_1.MODULE_VERSION;\nExampleModel.view_name = 'ExampleView'; // Set to null if no view\nExampleModel.view_module = version_1.MODULE_NAME; // Set to null if no view\nExampleModel.view_module_version = version_1.MODULE_VERSION;\nclass ExampleView extends base_1.DOMWidgetView {\n    render() {\n        this.el.classList.add('custom-widget');\n        const component = react_1.default.createElement(ReactWidget_1.default, {\n            model: this.model,\n        });\n        react_dom_1.default.render(component, this.el);\n    }\n}\nexports.ExampleView = ExampleView;\n//# sourceMappingURL=widget.js.map","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".custom-widget {\\n  padding: 0px 2px;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","var api = require(\"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../node_modules/css-loader/dist/cjs.js!./widget.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};"],"names":[],"sourceRoot":""}